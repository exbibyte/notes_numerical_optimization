\documentclass[8pt,letter]{article}

%% \usepackage[fleqn]{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsfonts,amsthm,bm}
\usepackage{breqn}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[ruled,vlined,linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{subcaption}
%% \usepackage{datetime}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{mathrsfs}
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{parskip} %turns off paragraph indent
\pagestyle{fancy}

\usepackage{xcolor}
\usepackage{mdframed}

\usetikzlibrary{arrows}

\DeclareMathOperator*{\argmin}{argmin}
\newcommand*{\argminl}{\argmin\limits}

\newcommand{\mathleft}{\@fleqntrue\@mathmargin0pt}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}} 
\newcommand{\N}{\mathbb{N}}
\newcommand{\ppartial}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\p}{\partial}
\newcommand{\te}[1]{\text{#1 }}
\newcommand{\norm}[1]{\|#1\|}

\setcounter{MaxMatrixCols}{20}

% remove excess vertical space for align equations
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{0pt}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

% \newtheorem{mdtheorem}{Theorem}
% \newenvironment{theorem}
% {\begin{mdframed}[
%   backgroundcolor=green!10,
%   topline=false,
%   rightline=false,
%   bottomline=false,
%   leftline=false
%   ]\begin{mdtheorem}}
%     {\end{mdtheorem}\end{mdframed}}

\begin {document}

\lhead{Notes - Numerical Optimization}

\begin{multicols*}{2}

  \section{General}

  line search conditions (1st and 2nd order), how to choose step length and direction:\\
  
  sufficient decrease, proportional to $\alpha_k$ step length and directional derivative $\nabla f_k^T p_k$:
  \begin{align}
    f_{k+1}^T & \leq f_k + c_1 \alpha_k \nabla f_k^T p_k\\
    \nabla f_k^T p_k & \leq 0\ //by\ construction
  \end{align}
  curvature:
  \begin{align}
    \nabla f_{k+1}^T p_k & \geq c_2 \nabla f_k^T p_k\\
    \frac{\partial \phi(\alpha_k)}{\partial \alpha_k} & \geq \frac{\partial \phi(0)}{\partial \alpha_k}\\
              &c_1,\alpha_k \in (0,1)\\
    &0<c_1<c_2<1
  \end{align}
  \begin{align*}
  \text{where}:& f_{k} = f(x_k)\\
  & f_{k+1} = f(x_k+\alpha_k p_k)\\
  & \phi(\alpha_k) = f(x_k + \alpha_k p_k)\\
  & \frac{\partial \phi(\alpha_k)}{\partial \alpha_k} = \nabla f_{k+1}^T p_k\\
  & \frac{\partial \phi(0)}{\partial \alpha_k} = \nabla f_{k}^T p_k //initial\ slope
  \end{align*}

  strong Wolfe curvature condition, to restrict large positive derivative:
  \begin{align}
    | \nabla f_{k+1}^T p_k| \leq c_2 |\nabla f_k^T p_k|
  \end{align}
  
  Form of search direction:
  \begin{align}
    p_k = - B_k^{-1} \nabla f_k
  \end{align}
  
  $B_k$ symmetric, non-singular, postive definite $\implies$ $p_k$ is a descent direction:
  \begin{align}
    \nabla f_k^T(-B_k^{-1} \nabla f_k) < 0
  \end{align}

  Goldstein condition (may miss minimizer of $f$):
  \begin{align}
    &f_k+(1-c) \alpha_k \nabla f_k^T p_k \leq f_{k+1} \leq f_k + c \alpha \nabla f_k^T p_k\\
    &c \in (0,\frac{1}{2})
  \end{align}
  
  \begin{algorithm}[H]
    \SetKwInOut{Input}{$f, x, d, c_1, \alpha, \beta$}\SetKwInOut{Output}{$\alpha$}
    \Input{function, x, direction, gradient threshold, initial step length, contraction}
    \Output{found step length}
    \While{$f(x + \alpha d) > f(x) + c_1 \alpha \nabla f(x)^T d$}{
      $\alpha \leftarrow \alpha * \beta$\\
    }
    return $\alpha$
    \caption{Line Search\label{Algo_LineSearch}}
  \end{algorithm}
  
  % Todo: add section on derivatives

  \section{Conjugate Gradient}

  \subsection{linear method}
  Assuming unconstrained problem with strict convex quadratic objective function:
  \begin{align*}
    \frac{1}{2} x^TAx-b^Tx, A \succ 0, A^T=A
  \end{align*}


  $\nabla(\frac{1}{2} x^TAx-b^Tx) = Ax-b$, thus $\min_x x^TAx - b^Tx$ transformed to solving $Ax-b=0$. 

  let $x_{k+1} = x_k + \alpha_k p_k$, solve for $\alpha$:
  \begin{align*}
    %%     &\frac{\partial}{\partial \alpha} (\frac{1}{2}(x_k + \alpha_k p_k)^T A (x_k + \alpha_k p_k) - b^T(x_k + \alpha_k p_k)) = 0\\
    &Ax_{k+1}-b=0\\
    &A(x_k+\alpha_k p_k) - b=0\\
    &\alpha_k A p_k = b - Ax_k\\
    &r_k = Ax-b\\
    &\alpha_k A p_k = -r_k\\
    &\alpha_k p_k^T A p_k = - p_k^T r_k\\
    &\alpha_k = - \frac{p_k^T r_k}{p_k^T A p_k}
  \end{align*}
  
  \subsection{Conjugate Direction}
  
  Enforce by construction for search directions linearly independent wrt. A.:
  \begin{align*}
    (\forall i\not=j) p_i^T A p_j = 0
  \end{align*}
  Properties:
  \begin{itemize}
  \item Residual elimnated one direction at a time, resulting in max of n iterations.
  \item Optimal if Hessian is diagonal, if not can try preconditioning.
  \item Current residual is orthogonal to all previous search directions.
  \item Any set of conjugate directions can be used:
    \begin{itemize}
    \item eigenvectors
    \item Gram-Schmidt
    \item conjugate gradient algo.
    \end{itemize}
  \end{itemize}
    
  \subsubsection{Termination Steps}
  \begin{theorem}[Conjugate Direction Termination]\label{thm:CD_Term}
    Conjugate direction algorithm converges to solution $x \in \R^n$ of linear system in n steps. Theorem [T5.1] in Num. Opt. book.
  \end{theorem}
  \begin{proof}
    \begin{align*}
      &\text{given:}\\
      &x_{k+1} = x_k + \alpha_k p_k\\
      &\alpha_k = - \frac{r_k^T p_k}{p_k^T A p_k}\\
      &(\forall i \neq j) p_i^T A p_j = 0\ \text{[A conjugate]}\\
      &\text{then:}\\
      &x^*-x_0 = \sum_{i=0}^{n-1} \sigma_i p_i\\
      &p_k^T A(x^*-x_0) = p_k^T A(\sum_{i=0}^{n-1} \sigma_i p_i)\\
      &\sigma_i = \frac{p_k^T A(x^*-x_0)}{p_k^T A p_k}\ \text{(from conjugacy)}\\
      &x_k = x_0 + \sum_{i=0}^{k-1} \alpha_i p_i\\
      &p_k^T A x_k = p_k^T A (x_0+\alpha_0 p_0 + ..)\\
      &p_k^T A x_k = p_k^T A x_0\ \text{(from conjugacy)}\\
      &p_k^T A (x_k-x_0) = 0\\
      &p_k^T A(x^*-x_0) = p_k^T A(x^*-x_k)\\
      &p_k^T A(x^*-x_0) = p_k^T(b-Ax_k) = -p_k^T r_k\\
      &\sigma_i = \frac{-p_k^T r_k}{p_k^T A p_k} = \alpha_k\\
      &\alpha_k\ \text{is 1D minimizer of kth coordinate by construction}
    \end{align*}
    Conjugate direction algo. terminates in n steps.
  \end{proof}

  If A is not diagonal, can transform coordinates:
  \begin{align*}
    S\hat{x} &= x\\
    S &=[p_0\ p_1\ ..\ p_{n-1}],\ (\forall i \neq j)\ p_i A p_j =0\\
    \phi(x) &= \frac{1}{2} x^T A x - b^T x\\
    \phi(\hat{x}) &= \frac{1}{2} \hat{x}^T S^T A S \hat{x} - (S^T b)^T \hat{x}\\
    S^T A S\ diagonal & \implies \text{can optimize one coordinate at a time}\\
  \end{align*}
  
  \vfill\null
  \columnbreak
  
  \subsubsection{Expanding subspace minimizer}
  Using conjugate directions to generate sequence $\{x\}$, then:\\
  $r_k^T p_i = 0, \forall i < k$, $x_k$ is minimizer of $\frac{1}{2} x^TAx - b^Tx$ over $\{ x | x= x_0 + span\{p_0,...p_{k-1}\}$
  \begin{proof}
    \begin{align*}
      &\tilde{x} = x_0 + \sum_i \sigma_i p_i\\
      &\tilde{x} \text{ minimizes over }\{x_0 + span\{ p_0, ... p_{k-1}\}\} \iff r(\tilde{x})^Tp_i = 0\\
      &h(\sigma) = \phi(\tilde{x})\\
      &\phi(x) =\frac{1}{2}x^TAx-b^Tx\\
      &\text{h is also strictly convex quadratic,}\\
      &\text{with unique }\sigma^*\text{ satisfying:}\\
      &\frac{\partial h(\sigma^*)}{\partial \sigma_i} = 0, i=[0,k-1]\\
      &\frac{\partial h(\sigma^*)}{\partial \sigma_i} = \nabla \phi(\tilde{x})^T p_i = 0, i = [0,k-1]\\
      &\nabla \phi(x) = Ax-b=r\\
      &r(\tilde{x})^T p_i = 0, i=[0,k-1]\\
    \end{align*}  
  \end{proof}
  $p_i^T r_k=0, i=[0,k-1]$ via induction:
  \begin{proof}
    \begin{align*}
      &\text{base case of k=1, i=0}: x_1 = x_0 + \alpha_0 p_0 \text{ minimizes } \phi \text{ along } p_0\\
      &\implies r_1^T p_0 = (r_0 + \alpha_0  A p_0)^T p_0= 0 \\
      &\text{case: }r_{k-1}^T p_i = 0, i=[0,k-2]:\\
      &r_k = r_{k-1} + \alpha_{k-1} A p_{k-1}\\
      &(\forall i\in[0,k-2]) p_i^T r_k = p_i^T r_{k-1} + \alpha_{k-1} p_i^T A p_{k-1}\\
      &(\forall i=[0,k-2]) p_i^T A p_{k-1}=0\ \text{(A-conjugacy by construction)}\\
      &(\forall i=[0,k-2]) p_i^T r_{k-1} = 0\ \text{(by induction hypothesis)}\\
      &p_i^T r_k = 0, i=[0,k-1]
    \end{align*}
  \end{proof}

  \vfill\null
  \pagebreak
  
  \subsection{Conjugate Gradient Method}
  Idea:
  \begin{itemize}
  \item uses only previous search direction to compute current search direction
  \item $p_k$ set to linear combination of $-r_k$ and $p_{k-1}$
  \item impose $p_k^T A p_{k-1}=0$
  \end{itemize}
  \begin{align*}
    p_k &= -r_k + \beta_k p_{k-1}\\
    p_{k-1}^T A p_k &= -p_{k-1}^T A r_k + \beta p_{k-1}^T A p_{k-1}\\
    0 &= -p_{k-1}^T A r_k + \beta p_{k-1}^T A p_{k-1}\\
    \beta &= \frac{p_{k-1}^T A r_k}{p_{k-1}^T A p_{k-1}}\\
    p_0& = -(Ax_0-b)=-r_0
  \end{align*}
  \begin{algorithm}[H]
    $x_0 = ..$\\
    $r_0 \leftarrow Ax_0-b$\\
    $p_0 = -r_0$\\
    \For{$k=[0,..n-1]$}{
      \uIf{$r_k==0$}{
        return $x_k$
      }
      \Else{
        $\alpha_k \leftarrow \frac{-r_k^Tp_k}{p_k^T A p_k} = \frac{r_k^T r_k}{p_k^T A p_k}$\\
        $x_{k+1} \leftarrow x_k + \alpha_k p_k$\\
        $r_{k+1} \leftarrow Ax_{k+1} - b = r_k + \alpha_k A p_k$\\
        $\beta_{k+1} \leftarrow \frac{p_k^T A r_{k+1}}{p_k^T A p_k}=\frac{r_{k+1}^T r_{k+1}}{r_k^T r_k}$\\
        $p_{k+1} \leftarrow -r_{k+1} + \beta_{k+1} p_k$
      }
    }
    \caption{Basic Conjugate Gradient Algorithm\label{Algo_CGBasic}}
  \end{algorithm}
  $p_k$ and $r_k$ is within krylov subspace:\\
  $K(r_0;k) =span\{r_0, Ar_0, ..A^k r_0\}$\\
  if $r_k \not= 0$:\\
  $r_k^T r_i = 0, i=[0,k-1]$\\
  $span\{r_0,..,r_k\} = span\{r_0,Ar_0,..,A^k r_0\}$\\
  $span\{p_0,..,p+k\}=span\{r_0,Ar_0,..,A^k r_0\}$\\
  $p_k^T A p_i=0, i=[0,k-1]$\\
  then, $\{x_k\} \rightarrow x^*$ in at most n steps.\\

  \vfill\null
  \columnbreak
  
  Simplification:
  \begin{align*}
    &p_{k+1} \leftarrow -r_{k+1} + \beta_{k+1} p_k\\
    &\alpha_k \leftarrow \frac{-r_k^Tp_k}{p_k^T A p_k}\\
    &\alpha_k \leftarrow \frac{-r_k^T(-r_{k} + \beta_{k} p_{k-1})}{p_k^T A p_k}\\
    &(\forall i=[0,k-1]) r_k^T p_i=0 \implies \beta_k r_k^T p_{k-1}=0\\
    &\alpha_k \leftarrow \frac{r_k^T r_k}{p_k^T A p_k} \ \text{(simplified)}
  \end{align*}
  \begin{align*}
    &r_{k+1}=r_k+\alpha_k A p_k\\
    &A p_k = \frac{r_{k+1}-r_k}{\alpha_k}\\
    &\beta = \frac{p_k^T A r_{k+1}}{p_k^T A p_k}\\
    &p_k^T A p_k = p_k^T \frac{r_{k+1}-r_k}{\alpha_k}= \frac{-p_k^T r_k}{\alpha} (\text{conjugacy})\\
    &p_k^T A p_k = -\frac{(- r_k + \beta_k p_{k-1})^T r_k}{\alpha}=\frac{r_k^T r_k}{\alpha} (\text{conjugacy})\\
    &p_k^T A r_{k+1} = r_{k+1}^T A p_k\\
    &p_k^T A r_{k+1} = r_{k+1}^T \frac{r_{k+1}-r_k}{\alpha_k}\\
    &r_k \in span\{p_k,p_{k-1}\}\ and\ r_{k+1}^T p_i = 0, i=[0,k] \implies\\
    &p_k^T A r_{k+1} = \frac{r_{k+1}^T r_{k+1}}{\alpha_k}\\
    &\beta_{k+1} \leftarrow \frac{r_{k+1}^T r_{k+1}}{r_k^T r_k} \ \text{(simplified)}
  \end{align*}

  \subsection{Nonlinear Method}
  Minimize general convex function or nonlinear function. Variants: FR, PR.

  \subsubsection{FR (Fletcher Reaves)}
  Modify linear CG by:
  \begin{itemize}
  \item replace residual by gradient of nonlinear objective, $r_k \rightarrow \nabla f_k$
  \item replace $\alpha_k$ computation by a linear search to find approx. minimum along search direction of $f$
  \end{itemize}

  Equivalent to linear CG if objective is strongly convex quadratic.\\

  Linear search for $\alpha_k$ with strong Wolfe condition to ensure $p_k$'s are descent directions wrt. objective function.\\
  
  \subsubsection{PR}
  Replace $\beta_{k+1}$ computation in FR with:
  \begin{align*}
    \beta_{k+1}^{PR} & \leftarrow \frac{\nabla f_{k+1}^T (\nabla f_{k+1} - \nabla f_k)}{\nabla f_k^T \nabla f_k}\\
    \beta_{k+1}^+ & \leftarrow \max(\beta_{k+1}^{PR}, 0)
  \end{align*}


  CG Gradient Algo. Property [T.5.3]:
  \begin{align*}
    &(\forall i=[0,k-1])\ r_k^T r_i=0\\
    &span\{r_0,..,r_k\} = span\{r_0,Ar_0,..,A^kr_0\}\\
    &span\{p_0,..,p_k\} = span\{r_0,Ar_0,..,A^kr_0\}\\
    &(\forall i=[0,k-1])\ p_k^T A p_i = 0\\
    &\implies \{x_k\}\ \text{converges to } x^*\ \text{in at most n steps}    
  \end{align*}
  Proof by induction to show generated search direcitons are A-conjugate. Then apply Theorem \ref{thm:CD_Term} to conclude algo terminates within n steps.
  
  \vfill\null
  \columnbreak
  
  \section{Quasi Newton}

  \subsection{Concept}
  properties: $O(n^2)$, self correcting, slightly more iterations than Newton Method, linear convergence order and superlinear rate of convergence

  Derivation, using 2nd order model, with $B_k$ SPSD:
  \begin{align*}  
    m_k(p)=f_k + \nabla f_k^T p + \frac{1}{2} p^T B_k p
  \end{align*}
  taking gradient wrt. $p$ and solve, assuming minimum exists:
  \begin{align*}  
    0 & = \nabla f_k + B_k p\\
    p & = - B_k^{-1} \nabla f_k
  \end{align*}
  update equation:
  \begin{align*}
    x_{k+1} & = x_k + \alpha_k p_k\\
    x_{k+1} & = x_k - \alpha_k B_k^{-1} \nabla f_k
  \end{align*}
  pick $\alpha$ to satisfy Wolfe conditions

  updated model at next iterate $x_{k+1}$:
  \begin{align*}
    m_{k+1}(p)=f_{k+1} + \nabla f_{k+1}^T p + \frac{1}{2} p^T B_{k+1} p
  \end{align*}
  impose reasonable conditions:
  \begin{enumerate}
  \item gradient of $m_{k+1}$ matches gradient of objective function $f$ at iterate $x_k$
  \item gradient of $m_{k+1}$ matches gradient of objective function $f$ at iterate $x_{k+1}$
  \end{enumerate}
  \begin{align*}
    \nabla m_{k+1}(0) & = \nabla f_{k+1} \implies \text{ condition 2 satisfied}
  \end{align*}

  for condition 1 (gradient of $m_{k+1}$ match gradient of objective $f$ at iterate $x_k$):
  \begin{align*}
    \nabla m_{k+1}(-\alpha_k p_k) &= \nabla f_{k+1} - \alpha_k B_{k+1} p_k = \nabla f_k\\
    \nabla f_{k+1} - \nabla f_k &= \alpha_k B_{k+1} p_k\\
    y_k &= \nabla f_{k+1} - \nabla f_k\\
    s_k &= x_{k+1} - x_k = \alpha_k p_k\\
    y_k &= B_{k+1} s_k \text{ [secant equation]}
  \end{align*}

  $B_{k+1}$ SPD $\implies s_k^T B_{k+1} s_k = s_k^T y_k > 0$\\
  $f$ strongly convex $\implies s_k^T y_k > 0$ satisfied for any 2 points $x_k$ and $x_{k+1}$.\\
  $f$ nonconvex $\implies$ need to enforce $s_k^T y_k$ by Wolfe conditions, and use line search for step length $\alpha$.
  
  Using line search ensures curvature condition:
  \begin{proof}
    \begin{align*}
      &s_k=x_{k+1} - x_k = \alpha_k p_k\\
      &y_k = \nabla f_{k+1} - \nabla f_k\\
      &\text{Wolfe curvature condition:}\\
      &\nabla f_{k+1}^T p_k \geq c_2 \nabla f_k^T p_k, c_2 \in (0,1)\\
      &y_k^T s_k = (\nabla f_{k+1} - \nabla f_k)^T (\alpha_k p_k)\\
      &y_k^T s_k = \alpha_k (\nabla f_{k+1} - \nabla f_k)^T p^k\\
      &y_k^T s_k = \alpha_k (c_2 \nabla f_k - \nabla f_k)^T p^k\\
      &y_k^T s_k = \alpha_k (c_2-1) \nabla f_k^T p^k\\
      &\alpha > 0 \wedge c_2-1 < 0 \wedge \nabla f_k^T p_k < 0 (p_k \text{ is a descent dir})\\
      &\implies y_k^T s_k > 0
    \end{align*}
    Curvature condition holds when Wolfe line search is performed.
  \end{proof}

  Choosing approximate Hessian, $B$:
  
  Force a unique solution among infinite many due to extra degrees of freedom in the matrix, few (n) constraining conditions imposed by secand equation, few (n) constraining conditions of PD. One approach is solving a optimization problem to make row rank update to previous iterate:
  \begin{align*}
    \min_B & ||B-B_k||\\
    s.t.\ &B=B^T \\
    &Bs_k=y_k \text{ [secant equation]}\\
    &B \succ 0
  \end{align*}
  alternatively, constrain $B$'s inverse, $H$:
  \begin{align*}
    \min_H & ||H-H_k||\\
    s.t.\ &H=H^T\\
    &Hy_k=s_k
    &H_{k+1}y_k & = s_k \text{ [secant equation]}\\
  \end{align*}
  
  Different norms can be used. One choice: weighted Frobenius norm:
  \begin{align*}
    ||A||_W & := ||W^{1/2}AW^{1/2}||_F\\
    ||X||_F & := (\sum_i \sum_j (X_{ij})^2)^{1/2}
  \end{align*}

  \subsection{DFP update algorithm}
  let $\bar{G_k}$ be the average Hessian:
  \begin{align*}
    \bar{G_k} = \int_0^1 \nabla^2 f(x_k + \tau \alpha_k p_k) d \tau
  \end{align*}
  using Taylor's theorem:\\
  $y_k = \bar{G_k} s_k = \bar{G_k} \alpha_k p_k$\\
  let $W=\bar{G_k}^{-1}$\\
  solve optimization problem:
  \begin{align*}
    &\min_B \| B - B_k \|_W\\
    s.t.\ &W=\bar{G_k}^{-1}\\
    &Bs_k=y_k\\
    &B=B^T
  \end{align*}
  
  Solution:
  \begin{align*}
    B_{k+1} &= (I-\rho_k y_k s_k^T)B_k(I - \rho_k s_k y_k^T) + \rho_k y_k y_k^T\\
    \rho_k &= \frac{1}{y_k s_k}
  \end{align*}

  Computation simplification: optimize for inverse Hessian instead  which is used in update of search direction: $p_k = - B_k^{-1} \nabla f_k$\\
  Use Sherman-Morrison-Woodbury formula to obtain inverse.\\
  let $H_k = B_k^{-1}$, then DFP update becomes:\\
  \begin{align*}
    H_{k+1} = H_k - \frac{H_k y_k y_k^T H_k}{y_k^T H_k y_k} + \frac{s_k s_k^T}{y_k^T s_k}
  \end{align*}
  This is a rank 2 modification to previous iterate for efficiency.
  
  \subsection{BFGS update algorithm}

  Idea: impose condition on inverse of Hessian instead of Hessian approximation.\\

  let $H$ be approximate inverse of Hessian, then impose:
  \begin{align*}
    H_{k+1} \succ 0\\
    H_{k+1} = H_{k+1}^T\\
    H_{k+1} y_k = s_k
  \end{align*}

  solve for $H$ in the optimization problem:
  \begin{align*}
    &\min_H \|H-H_k\|_W\\
    s.t.\ &H=H^T\\
    &H y_k = s_k\\
  \end{align*}
  where $y_k=W s_k$\\
  
  let $W$ be the average Hessian:\\
  $\bar{G_k}=\int_0^1 \nabla^2 f(x_k + \tau \alpha_k p_k) d \tau$\\

  solve to obtain:
  \begin{align*}
    H_{k+1} & = (I-\rho_k s_k y_k^T) H_k (I - \rho_k y_k s_k^T) + \rho_k s_k s_k^T\\
    \rho_k & = \frac{1}{y_k^T s_k}
  \end{align*}
  
%%   Weight matrix $W$ satisfies $Ws_k=y_k$.\\
%%   $W$ is the average Hessian $\bar{G}$:
%%   \begin{align*}
%%     \bar{G} = \int_0^1 \nabla^2 f(x_k+\tau \alpha_k p_k) d\tau
%%   \end{align*}

%%   solution given by:
%%   \begin{align*}
%%     H_{k+1} & = (I-\rho_k s_k y_k^T)H_k(I-\rho_ky_ks_k^T) \\
%%             &+ \rho_k s_k^T s_k\\
%%     \rho_k & = \frac{1}{y_k^Ts_k}
%%   \end{align*}
  
  initial $H_0$ can be chosen approximately:
  \begin{itemize}
  \item finite diferences
  \item $\alpha I$
  \end{itemize}
  
  \begin{algorithm}[H]
    \SetKwInOut{Input}{$H_0,x_0,\epsilon>0$}\SetKwInOut{Output}{$x$}
    \Input{inverse Hessian approx., initial point, convergence tolerance}
    \Output{solution}
    $k \leftarrow$ 0\\
    $p_k \leftarrow -B^{-1} \nabla f(x_k) = -H\nabla f(x_k)$\\
    \While{$||\nabla f_k|| > \epsilon$}{
      $\alpha_k \leftarrow $ LineSearch(..)\\
      $x_{k+1} \leftarrow x_k + \alpha_k p_k$\\
      $s_k \leftarrow x_{k+1} - x_k$\\
      $y_k \leftarrow \nabla f_{k+1} - \nabla f_k$\\
      $\rho_k \leftarrow \frac{1}{y_k^Ts_k}$\\
      $H_{k+1} \leftarrow (I-\rho_k s_k y_k^T)H_k(I-\rho_ky_ks_k^T) + \rho_k s_k s_k^T$\\
      $k \leftarrow k+1$\\
    }
    return $x$
    \caption{BFGS Algorithm\label{Algo_BFGS}}
  \end{algorithm}

  Cost: $O(n^2)$ + cost of eval $f(.)$ + cost of eval $\nabla f(.)$.\\
  Order of convergence: superlinear, worse than Newton but more computationally efficient than Newton.\\   
  
  Using Sherman-Morrison-Woodbury formula to obtain Hessian update equation,
  \begin{align*}
    B_{k+1} & = B_k - \frac{B_ks_k s_k^T B_k}{s_k^T B_k s_k} + \frac{y_k y_k^T}{y_k^T s_k}
  \end{align*}
  , but is it more efficient to use the inverse version.\\
  
  Proper line search is required so that BFGS algo captures curvature information.\\
  
  Inaccurate line search can be used to reduce computation cost.
  \vfill\null
  
  % \pagebreak
  
  \section{Trust Region Methods}
  idea:
  \begin{itemize}
  \item models local behaviour of the objective function (eg: 2nd order Taylor series)
  \item set local region to explore, then simultaneously find direction and step size to take
  \item region size adaptively set using results from previous iterations, using ratio of function value decrease vs. model value decrease
  \item step may fail due to inadequately set region, which need to be adjusted
  \item superlinear convergence when approximate model Hessian is equal to true Hessian
  \end{itemize}

  using 2nd order Taylor series model with symmetric matrix approximating Hessian
  \begin{align*}
    \min_{p \in \R^n} m_k(p) & = f_k + g_k^Tp + \frac{1}{2}p^TB_kp,\ st.\ ||p||\leq \Delta_k\\
    \Delta_k & :=\text{trust region radiius}\\
    g_k & =\nabla f(x_k)\\
    B_k & \succeq 0\\
    B_k^T & = B_k
  \end{align*}
  
  full step is ($p_k=-B_k^{-1}g_k)$ taken when $B\succ 0 $ and $||B_k^{-1} g_k|| \leq \Delta_k$

  evaluate goodness of model with $\frac{\text{actual function value change}}{\text{predicted model change}}$:
  \begin{align*}
    &\rho_k = \frac{f(x_k)-f(x_k+p_k)}{m_k(0)-m_k(p_k) \geq 0}\\
    &action \leftarrow
      \begin{cases}
        \text{expand trust region} &, \rho_k \approx 1\ (agreement)\\
        \text{shrink trust region} &, \rho_k  < 0 + \text{thresh}\\
        \text{keep trust region} &, o/w
      \end{cases}  
  \end{align*}

  \begin{algorithm}[H]
    $k \leftarrow$ 0\\
    \While{$||\nabla f_k|| > \epsilon$}{
      $p_k \leftarrow
      \argminl_{p} f_k + g_k^Tp + \frac{1}{2}p^TB_kp,\ st.\ ||p||\leq \Delta_k$\\
      $\rho_k = \frac{f(x_k)-f(x_k+p_k)}{m_k(0)-m_k(p_k)}$//ratio test\\
      //change trust region for next iterate\\
      \uIf{$\rho_k<\gamma (:\frac{1}{4})$}{
        $\Delta_{k+1} \leftarrow \alpha (:\frac{1}{4}) \Delta_k //shrink$
      }
      \uElseIf{$\rho_k> \beta (:\frac{3}{4})\ and\ ||p_k|| == \Delta_k$}{
        $\Delta_{k+1} \leftarrow min(2 \Delta_k, \hat{\Delta}) //expand$
      }
      \Else{
        $\Delta_{k+1} \leftarrow \Delta_k //keep$
      }

      //accept/reject for current iterate\\
      \uIf{$\rho_k > \eta (: \in [0, \frac{1}{4}))$}{
        $x_{k+1} \leftarrow x_k + p_k$
      }
      \Else{
        $x_{k+1} \leftarrow x_k$
      }
    }
    \caption{Trust Region Algorithm\label{Algo_TrustRegion}}
  \end{algorithm}

  Minimizer of the 2nd order Taylor series satisfy the following as a global solution for trust region iff:
  \begin{align*}
    (B+\lambda I)p^*=-g\\
    \text{complementary slackness:}\\
    \lambda(\Delta - ||p^*||)=0\\
    (B+\lambda I) \succeq 0\\
    \lambda \geq 0
  \end{align*}

  \begin{align*}
    \lambda \ge 0 \implies p \text{ parallel to negative gradient of model}
  \end{align*}
  
  Solving 2nd order Taylor series using approx methods, which reduce at least as much as Cauchy Point:
  \begin{itemize}
  \item dogleg (positive definite)
  \item 2-D subspace minimization (require smallest eigenvalue estimation if not positive definite)
  \item conjugate gradient based, effective when $B$ large, sparse
  \end{itemize}
  
  Cauchy Point (sufficient reduction in model value):\\
  Use 1st order approx. of model and steepest descent direciton to get next iterate, bounded within trust region.\\

  [TODO: insert section on Cauchy Point]\\
  
  \subsection{Dogleg method}
  if $B \succ 0$:\\
  $p^B=-B^{-1}g$\\
  $p^*=p^B$ if $\Delta \geq \|p^B\|$\\
  $p^U=\frac{-g^Tg}{g^TBg}g$ (intermediate point along direction of steepest descent)\\
  Resulting algo, interpolate between $p^U$ and $p^B$:\\
  $\tilde{p}(\tau) =
  \begin{cases}
    \tau p^U &, \tau_\in [0,1]\\
    p^U + (\tau-1)(p^B-p^U) &, \tau \in [1,2]
  \end{cases}
  $
  \begin{align*}
    B \succ 0 \implies & \|\tilde{p}(\tau)\| \text{increases wrt. }\tau\ \land\\
    & m(\tilde{p}(\tau)) \text{decreases wrt. } \tau
  \end{align*}
  
  if $\|p^B\| \leq \Delta$: $p$ chosen at $p^B$\\
  else $p$ chosen at intersection of $\tilde{p}(\tau)$ and trust region boudnary by solving:\\
  $\|p^U+(\tau-1)(p^B-p^U)\|^2 = \|\Delta^2\|$

  $p_k^S=\argminl_p f_k+g_k^Tp, \|p\| \leq \Delta_k$\\
  $\tau_k = \argminl_{\tau\geq0} m_k(\tau p_k^S), \|\tau p_k^S\| \leq \Delta_k$\\
  $p_k^S=\frac{-\Delta_k g_k|}{\|g_k\|}$\\
  $p_k^C=\tau_k p_k^S$\\
  $p_k^C=-\tau_k \frac{\Delta_k g_k}{\|g_k\|}$\\
  $\tau_k=\begin{cases}
    1 &, g_k^T B_k g_k \leq 0\\
    min(\frac{\|g_k|^3}{\Delta_k g_k^T B_k g_k}, 1) &, o/w
  \end{cases}$

  [TODO: add section on 2D subspace minimization method]\\
  
  \vfill\null
  % \pagebreak

  \subsection{Iterative Solution}
  Idea: solve subproblem $\min_{\|p\| \leq \Delta} m(p)$ by applying Newton's method to find $\lambda$ that matches trust region radius. This is slightly more accurate per step compared to Dogleg. Use $(B+\lambda I)p^*=-g$ to solve $\min_{\|p\| \leq \Delta} m(p)$ for $\lambda$.

  If $\lambda=0$ and $(B+\lambda I)p^*=-g, \|p^*\| \leq \Delta$ and $(B+\lambda I) \succeq 0$: return $\lambda$\\
  Else: find $\lambda$ s.t. $(B+\lambda I) \succeq 0$ and $\|p(\lambda)\| = \Delta, p(\lambda)=-(B+\lambda I)^{-1}g$. Solve and return $\lambda$.
  
  Solve $\|p(\lambda)\|-\Delta=0, \lambda > \lambda_1$ via Newton's method (root finding). Approx. this to nearly a linear problem for easy solving:\\

  \begin{algorithm}[H]
    \For{$l=0,1,..$}{
      solve $B+\lambda ^l I = R^T R$\\
      $R^TR p_l = -g$\\
      $R^T q_l = p_l$\\
      $\lambda^{l+1} \leftarrow \lambda^l + (\frac{\|p_l\|}{\|q_l\|})^2(\frac{\|p_l\|-\Delta)}{\Delta})$
      check $\lambda \geq \lambda_1$
    }
    \caption{Subproblem Algo\label{Algo_TrustRegionIterativeSubproblem}}
  \end{algorithm}

  \vfill\null
  \columnbreak
    
  \subsection{Trust Region Newton CG Method}

  \label{section_trust_region_newton_cg}
  Idea: use trust region algo for the outer iteration, use iterative CG based algorithm to solve for inner optimization problem.

  Outer iteraion: Algo \ref{Algo_TrustRegion}.\\

  Inner optimization problem:
  \begin{align*}
    \min_{p \in \R^n} m(p) & = f + g^T p + \frac{1}{2} p^T B p\\
    & s.t.\ \|p\| \leq \Delta
  \end{align*}
  
  \begin{algorithm}[H]
    $\epsilon_k = \eta_k \| \nabla f_k\|$\\
    $z_0 = 0$\\
    $r_0 = \nabla f_k$\\
    $d_0 = -r_0 = \nabla f_k$\\
    \uIf{$\|r_0\| < \epsilon_k$}{
      return $p_k=z_0=0$
    }
    \For{$j=0,1,..$}{
      //dir of nonpositive curvature test\\
      \uIf{$d_j^T B_k d_j \leq 0$}{ 
        return $\argmin_{p_k} m_k(p_k=z_j + \tau d_j)$ s.t. $\|p_k\| = \Delta_k$
      }
      $\alpha_j = \frac{r_j^T r_j}{d_j^T B_k d_j}$\\
      $z_{j+1}=z_j + \alpha_j d_j$\\
      //trust region check\\
      \uIf{\|z_{j+1}\| \geq \Delta_k}{
        return $p_k : p_k = z_j + \tau d_j$ s.t. $\|p_k\| = \Delta_k, \tau \geq 0$
      }
      $r_{j+1} = r_j + \alpha_j B_k d_j$\\
      \uIf{$\|r_{j+1}\| < \epsilon_k=\eta_k \|\nabla f_k\|, \eta_k=min(\frac{1}{2},\|\nabla f_k\|^{\frac{1}{2}})$}{
        return $p_k=z_{j+1}$
      }
      $B_{j+1} = \frac{r_{j+1}^T r_{j+1}}{r_j^T r_j}$\\
      $d_{j+1} = -r_{j+1} + B_{j+1} d_j$\\
    }\\
    \caption{Trust Region Newton-CG Subproblem (CG Steinhaug) \label{Algo_CG_Steihaug}}
  \end{algorithm}
  
  $\epsilon_j$ can be chosen similarly as in Line Search Newton-CG method, where $\{\eta_k\}$ is the forcing sequence.
  
  \vfill\null
  \columnbreak  
    
  \section{Proximal Algorithm}
  Idea:
  \begin{itemize}
  \item reliance on easy to evaluate proximal operators
  \item separability allows parallel evaluation
  \item generalization of projection based algorithms
  \end{itemize}

  \begin{align*}
    prox_{\lambda f}(v) = \argminl_{x} f(x) + \frac{1}{2 \lambda} \|x-v\|_2^2
  \end{align*}

  Resolvent of subdifferential operator:
  \begin{align*}
    &z=prox_{\lambda f}(x) \implies z \in (I+\lambda \partial f)^{-1}(x)\\
    &(I+\lambda \partial f)^{-1} :=\text{resolvent of operator }\partial f
  \end{align*}
  
  \subsection{Proximal Gradient Method}
  Solve $\min_{x} g(x)+f(x)$, where $f,g$ are closed, convex functions and $f$ differentiable
  \begin{align*}
    &x^* = prox_{\lambda^k g}(x^k-\lambda^k \nabla f(x^k)) \\
    &=\argminl_{x} g(x) + \frac{1}{2 \lambda^k} \|x - (x^k - \lambda^k \nabla f(x^k))\|_2^2\\
    &\text{tradeoff between g and and gradient step}\\
    &g=I_C(x) \implies \text{projected gradient step}\\
    &g=0 \implies \text{gradient descent}\\
    &f=0 \implies \text{proximal minimization}
  \end{align*}

  Relation to Pixed Point:\\
  $x^*$ is a fixed point solution of $\min_{x} g(x)+f(x)$ iff $0 \in \nabla f(x^*) + \partial g(x^*)$ iff $x^* = (I+\lambda \partial g)^{-1}(I-\lambda \nabla f)(x^*)$\\
  
  Forward Euler, Backward Euler stepping is same as the proximal gradient iteration, $prox_{\lambda^k g}(x^k-\lambda^k \nabla f(x^k))$\\

  \subsection{Accelerated Proximal Gradient Method}
  Introduce extrapolation:
  \begin{align*}
    &y^{k+1} = x^k + w^k(x^k-x^{k-1})\\
    &x^{k+1} = prox_{\lambda^k g}(y^{k+1}-\lambda^k \nabla f(y^{k+1}))\\
    &w^k \in [0,1)
  \end{align*}

  Example: $w^k = \frac{k}{k+3}, w^0 = 0, \lambda^k \in (0,1/L], L:= \text{Lipschitz constant of }\nabla f,\ or\ \lambda^k$ found via line search.
  Line search for $\lambda^k$ (Beck and Teboulle):

  \begin{algorithm}[H]
    $\hat{f}(x,y):=f(y) + \nabla f(y)^T(x-y) + \frac{1}{2\lambda}\|x-y\|^2_2$\\
    \While{True}{
      $z = prox_{\lambda g}(y^k-\lambda \nabla f(y^k))$\\
      \uIf{$f(x) \leq \hat{f}(z,y^k)$}{
        break
      }
      $\lambda = \beta \lambda$
    }
    return $\lambda^k := \lambda, x^{k+1} := z$\\
    \caption{Proximal Gradient Algorithm\label{Algo_ProximalGradient}}
  \end{algorithm}

  \subsection{Types of Proximal Operators}
  \begin{itemize}
  \item quadratic functions
    \begin{align*}
      f&=\frac{1}{2} \|.\|_x^2 \implies prox_{\lambda f}(v) = (\frac{1}{1+\lambda})v\\
      f&=\frac{1}{2}x^T A x + b^T x + c, A \in S_+^n \implies\\
      &prox_{\lambda f}(v)=(I+\lambda)^{-1}(v-\lambda b)
    \end{align*}
  \item unconstrained problem: use gradient methods such as Newton, Quasi-Newton
  \item constrained: use projected subgradient for non-smooth, projected gradient or interior method for smooth
  \item separable function: if scalar, may be solved analytically, eg:
    L1 norm separable to:
    \begin{align*}
      f(x) = |x| \implies prox_{\lambda f}(v) =
      \begin{cases}
        v-\lambda ,& v \geq \lambda\\
        0,& |v| \leq \lambda\\
        v+\lambda, & v \leq -\lambda
      \end{cases}
    \end{align*}
    \begin{align*}
      f(x) = -log(x) \implies prox_{\lambda f}(v) = \frac{v+\sqrt{v^2+4\lambda}}{2}
    \end{align*}
  \item general scalar function
    \begin{itemize}
    \item localization: using a subgradient oracle and bisection algorithm
    \item twice continuously differentiable: guarded Newton method
    \end{itemize}
  \item polyhedra constraint, quadratic objective: solve as QP problem
    \begin{itemize}
    \item duality to reduce number of variables to solve if possible
    \item gram matrix caching
    \item affine constraint($Ax=b$): use pseudo-inverse, $A^{+}$:
      \begin{align*}
        \Pi_C(v) &= v - A^{+}(Av-b)\\
                 &A \in R^{m \times n}, m < n \implies A^{+} = A^T(AA^T)^{-1}\\
                 &A \in R^{m \times n}, m > n \implies A^{+} = (A^TA)^{-1}A^T
      \end{align*}
    \item hyperplane constaint($a^Tx=b$):
      \begin{align*}
        \Pi_C(v) = v + (\frac{b-a^Tb}{\|a\|_2^2})a
      \end{align*}
    \item halfspace
      \begin{align*}
        \Pi_C(v) = v - \frac{max(a^T v -b,0)}{\|a\|_2^2}a
      \end{align*}
    \item box($l\leq x \leq u$)
      \begin{align*}
        \Pi_C(v)_k = min(max(v_k, l_k), u_k)
      \end{align*}
    \item probability simplex($1^Tx= 1, x \geq 0$)\\
      bisection algo on $\nu$:
      \begin{align*}
        \Pi_C(v) = (v- \nu 1)_+\\
        \text{intial }[l_k,u_k] = [\max_i v_i-1, \max_i vi]
      \end{align*}
      analytically solve when bounded in between 2 adjacent v_i's      
    \end{itemize}
  \item cones ($\kappa$: proper cone)\\
    problem of the form:
    \begin{align*}
      min_x \|x-v\|_2^2\\
      s.t.: x\in \kappa
    \end{align*}
    \begin{align*}
      x \in \kappa\\
      v=x-\lambda\\
      \lambda\in\kappa^*\\
      \lambda^Tx=0
    \end{align*}
    \begin{itemize}
    \item cone $C=\R_+^n$
      \begin{align*}
        \Pi_C(v)=v_+
      \end{align*}
    \item 2nd order cone $C=\{(x,t)\in \R^{n+1}: \|x\|_2 \leq t\}$
      \begin{align*}
        \Pi_C(v,s) = \begin{cases}
          0,& \|v\|_2 \leq -s\\
          (v,s),& \|v\|_2 \leq s\\
          \frac{1}{2}(1+\frac{s}{\|v\|_2})(v,\|v\|_2),& \|v\|_2 \geq |s|
        \end{cases}
      \end{align*}
    \item PSD cone $S_+^n$
      \begin{align*}
        \Pi_C(V)&=\sum_i (\lambda_i)_+ u_i u_i^T\\
        V&=\sum_i \lambda_i u_i u_i^T\ (eigendecomp)
      \end{align*}
    \item exponential cone\\
      Todo
    \end{itemize}
  \item pointwise supremum
    \begin{itemize}
    \item max function
    \item support function
    \end{itemize}
  \item norms
    \begin{itemize}
    \item L2
    \item L1
    \item L-$\inf$
    \item elastic net
    \item sum of norms
    \item matrix norm
    \end{itemize}
  \item sublevel set
  \item epigraph
  \item matrix functions
    Todo
  \end{itemize}

  \vfill\null
  \columnbreak
    
  \section{Smoothness}
  $\beta$ smoothness:
  \begin{align*}
    & \frac{\beta}{2} \|x\|_2^2 - f(x) \text{ is convex (fit quadratic on top)}\\
    & f(y) \leq f(x) + \nabla f(x)^T (y-x) + \frac{\beta}{2} \|y-x\|_2^2\\
    & \implies \text{f is smooth}
  \end{align*}

  $\alpha$ strong convexity:
  \begin{align*}
    & f(x) - \frac{\alpha}{2} \|x\|_2^2 \text{ is convex (fit quadratic below)}\\
    & f(y) \geq f(x) + \nabla f(x)^T (y-x) + \frac{\alpha}{2} \|y-x\|_2^2\\
    & \text{f may not be smooth}
  \end{align*}

  Smoothness near optimal point: there always exists a step (length $<\frac{2}{\beta}$) that is a descent direction.

  Property of f wrt. optimality value:\\
  f is $\beta$-smooth $\implies$
  \begin{align*}
    \frac{1}{2 \beta} \|\nabla f(x) \|_2^2 \leq f(x) -f(x^*) \leq \frac{\beta}{2} \| x-x^* \|_2^2
  \end{align*}
  f is $\alpha$-strongly convex $\implies$
  \begin{align*}
    \frac{\alpha}{2} \| x-x^* \|_2^2 \leq f(x) -f(x^*) \leq \frac{1}{2 \alpha} \|\nabla f(x) \|_2^2
  \end{align*}

  Co-coercivity for $\beta$-smooth $f$:
  \begin{align*}
    \left(\nabla f(x) - \nabla f(y)\right)^T(x-y) \geq \frac{1}{\beta} \|\nabla f(x) - \nabla f(y)\|_2^2
  \end{align*}
  Coercivity for $\alpha$-strongly convex $f$:
  \begin{align*}
    \left(\nabla f(x) - \nabla f(y)\right)^T(x-y) \geq \alpha \|x - y\|_2^2
  \end{align*}
  
  \subsection {Oracle based lower bounds}
  Lipschitz convex function: error=$\mathcal{O}(\frac{1}{\sqrt{T}})$\\
  Smooth convex function: $\epsilon=\mathcal{O}(\frac{1}{T^2})$\\
  Smooth + strongly convex function: $\epsilon=\mathcal{O}(\frac{\sqrt{\kappa}-1}{\sqrt{\kappa}+1})$

  \subsection {Gradient descent rate of convergence}
  $\beta$-smooth $f$: $\mathcal{O}(\frac{1}{T})$\\
  $\beta$-smooth + $\alpha$-strongly convex $f$: $\mathcal{O}((\frac{\sqrt{\kappa}-1}{\sqrt{\kappa}+1})^T)$

  \subsection {Gradient descent with momentum}
  $f$ $\beta$-smooth, $\alpha$-s.c.:
  \begin{align*}
    & x_1=y_1 = x_{init}\\
    & y_{t+1} = x_t - \frac{1}{\beta} \nabla f(x_t)\\
    & x_{t+1} = \left(1+\frac{\sqrt{\kappa}-1}{\sqrt{\kappa}+1}\right) y_{t+1} - \left(\frac{\sqrt{\kappa}-1}{\sqrt{\kappa}+1}\right) y_t
  \end{align*}

  $f$ $\beta$-smooth:
  \begin{align*}
    & x_{t+1}=x_t-\eta \nabla f(x_t) \text{ [normal GD]}\\
    & \text{momentum, nesterov accel.:}\\
    & d_{t+1} = \gamma_{t+1}(x_{t+1} - x_t)\\
    & x_{t+1} = (x_t + d_t) - \eta \nabla f(x_t + d_t)\\
    & \epsilon=\mathcal{O}\left(\frac{1}{T^2}\right)
  \end{align*}

  \section {Common Algorithms}

  \subsection {Projected Gradient}
  \begin{align*}
    & y_{t+1} = x_t - \eta g_t, g_t \in \partial f(x_t)\\
    & x_{t+1} = proj_{X}(y_{t+1})\\
    & x^*=proj_{X}(x^*) \text{ [fixed point at optimality]}
  \end{align*}

  \subsection {Proximal Gradient}
  \begin{align*}
    prox_{\eta h}(y) = \argmin_x h(x) + \frac{1}{2 \eta} \|x-y\|_2^2\\
    x_{t+1} = prox_{\eta h}(x_t - \eta \nabla f(x_t))
  \end{align*}
  Special case of projected gradient:\\
  let $h(x)=I_X(x) \implies prox_{\eta h} = proj_X$\\
  where $I_X(x) =
  \begin{cases}
    0 &, x \in X\\
    +\infty &, o/w
  \end{cases}$

  \subsubsection{Common proximal operators}
  $h(x) = \|x\|_1$:\\
  \begin{align*}
    (prox_{\eta h}(x))_i & = \begin{cases}
      x_i - \eta &, x_i \geq \eta\\
      0 &, |x_i| \leq \eta\\
      x_i + \eta &, x_i \leq -\eta
    \end{cases}\\
    & = \max(|x_i|-\eta,0)\ sign(x_i)
  \end{align*}
  
  $h(x)=\frac{1}{2} x^T Q x + q^T x + q_0, Q \succeq 0$:
  \begin{align*}
    prox_{\eta h} = (I + \eta Q)^{-1} (x- \eta q)
  \end{align*}

  $h(x)=\sum_i h_i(x_i)$:
  \begin{align*}
    (prox_{\eta h}(x))_i = prox_{\eta h_i}(x_i) \text{ [parallelism]}
  \end{align*}

  Composite function:\\
  $\min_x f(x) = g(x) + h(x)$, $g$ smooth, $h$ not smooth but has prox. operator.\\
  Convergence due to non-smooth function: $\mathcal{O}(\frac{1}{\sqrt{T}})$\\

  \subsection{L1 regularization with subgradient descent}
  
  \begin{align*}
    & \min_x \|Ax-y\|_2^2 + \labda \|x\|_1\\
    & g=\|Ax-y\|_2^2\\
    & h=\lambda \|x\|_1\\
    & \partial_x h(x) = \begin{cases}
      -1 &, x_i < 0\\
      [-1, 1] &, x_i = 0\\
      1 &, x_i > 0
    \end{cases}\\
    & x_{t+1} = x_t - \eta (\nabla g(x_t) + \lambda \partial h(x))\\
    & x_{t+1} = x_t - \eta (2A^T(Ax-y) + \lambda z)\\
    & z=\begin{cases}
    -1 &, x_i < 0\\
    [-1,1] &, x_i = 0\\
    1 &, x_i > 0
    \end{cases}
  \end{align*}
  Convergence: $\epsilon=\mathcal{O}\left(\frac{1}{\sqrt{T}}\right)
    
  \subsection{ISTA (with proximal gardient)}
  \begin{align*}
    & \min_x g(x) + h(x), g\ \beta\text{-smooth}\\
    & g(x) = \|Ax-y\|_2^2\\
    & h(x) \lambda \|x\|_1\\
    & x_{t+1} = prox_{\eta h}(x_t - \eta \nabla g(x_t))\\
    & g\ \beta \text{-smooth, select } \eta = \frac{1}{\beta}\\
    & x_{t+1} = prox_{\frac{1}{\beta} \lambda \|\dot\|_1}(x_t - \frac{1}{\beta} \nabla g(x_t))\\
    & x_{t+1} = \argmin_x \lambda \|x\|_1 + \frac{\beta}{2} \|x-(x_t-\frac{1}{\beta} \nabla g(x_t))\|_2^2\\
    & \nabla g(x_t) = 2A^T(Ax-y)
  \end{align*}
  Convergence: $\mathcal{O}\left(\frac{1}{\sqrt{T}}\right)

  \subsection{FISTA}
  \begin{align*}
    & \min_x g(x) + h(x), g\ \beta\text{-smooth}\\
    & \mu_0=0\\
    & \mu_t = \frac{1+\sqrt{1+4\mu_t^2-1}}{2}\\
    & \gamma_t = \frac{1-\mu_t}{\mu_{t+1}}\\
    & x_1=z_1=\text{arbitrary}\\
    & x_{t+1} = (1-\gamma_t) x_{t+1} + \gamma_t z_t\\
    & z_{t+1} = prox_{\frac{\lambda}{\beta}\| \dot \|_1}(x_t - \frac{1}{\beta} \nabla g(x_t))
  \end{align*}
  Convergence: $\epsilon=\mathcal{O}\left(\frac{1}{T^2}\right)

  
  \section{Subgradient Method}
  TODO

  \section{Large Scale Optimization}
\begin{enumerate}
  \item memory reduction techniques with quasi-Newton methods.
  \item Inexact Newton methods with superlinear local convergence properties, indefinite Hessian, Hessian-free impl.
  \item function that is partial separable to use smaller subspaces.
\end{enumerate}

  
  \subsection{Inexact Newton Methods}
  
  Iterative method with local convergence properties.\\
  Residual: $r_k = \nabla^2 f_k p_k + \nabla f_k$\\
  Termination condition for iterative solver: $\|r_k\| \leq \eta_k \|\nabla f_k\|, \eta_k \in (0,1)$, where ${\eta_k}$ is the forcing sequence.\\
  Convergence properties: see Thm 7.1, 7.2 (Nocedal)\\
  
  2 such algorithms, using CG as the iterative solver:
  \begin{enumerate}
  \item Line Search Newton-CG
  \item Trust Region Newton-CG (Section \ref{section_trust_region_newton_cg})
  \end{enumerate}

  \subsubsection{Line Search Newton-CG}
  Augment original CG algorithm with line search, curvature check and forcing function check.\\
    
  \begin{algorithm}[H]
    $x_0 = ..$\\
    \For{$k=0,1,..$}{
      \eta_k = \min(\frac{1}{2}, \| \nabla f_k\|^{\frac{1}{2}})\\
      $z_0 = 0, r_0=\nabla f_k, d_0=-r_0=-\nabla f_k$\\
      \For{$j=0,1,..$}{
        //choose direction\\
        \uIf{$d_j^T B_k d_j \leq 0$}{
          \uIf{$j=0$}{
            break $p_k = - \nabla f_k$
          }
          \Else{
            break $p_k = z_j$
          }
        }
        $\alpha_j = \frac{r_j^T r_j}{d_j^T B_k d_j}$\\
        $z_{j+1}  = z_j + \alpha_j d_j$\\
        $r_{j+1} = r_j + \alpha_j B_k d_j$\\\
        \uIf{$\|r_{j+1}\| < \epsilon_k = \eta_k \|\nabla f_k\|$}{
          break $p_k = z_{j+1}$
        }
        $B_{j+1} = \frac{r_{j+1}^T r_{j+1}}{r_j^T r_j}$\\
        $d_{j+1} = -r_{j+1} + B_{j+1} d_j$\\
      }
      $\alpha_k = $ Wolfe/Goldstein/Armijo step search\\
      $x_{k+1} = x_k + \alpha_k p_k$\\
    }\\
    \caption{Line Search Newton-CG Algo \label{Algo_line_search_newton_cg}}
  \end{algorithm}

  \subsection{Partially Separable Functions}
  Decompose into sum of element functions with a large number of variables being linearly independent.\\

  Ideally: $\nabla f(x) = \sum_i \nabla f_i(x), \nabla^2 f(x) = \sum_i \nabla^2 f_i(x)$.\\

  Use Hessian approximations for individual element functions.\\

  Use chain rule to transform into msaller spaces and back to original space via compactifying matrices.\\

  eg: $\nabla^2 f(_1(x) \approx U_i^T B_{[1]} U_i$ mapping $B_{[1]}$ back into correct position in the full Hessian approximation.

  \begin{align*}
    x_{[i]} &= U_i x\\
    f(x) &= \sum_i \phi_i(U_i x)\\
    \nabla f_i(x) &= U_i^T \nabla \phi_i(U_i x)\\
    \nabla^2 f_i(x) &= U_i^T \nabla^2 \phi_i(U_i x) U_i\\
  \end{align*}

  Use a Quasi-Newton to approximate $\nabla^2 \phi_i$ which require smaller resources by updating a new approximation $B_{[i]}$ iteratively:
  \begin{align*}
    s_{[i]} & = x_{[i]}^+ - x_{[i]}\\
    y_{[i]} & = \nabla \phi_i(x_{[i]}^+) - \nabla \phi_i(x_{[i]})\\
    B_{[i]} & \approx \nabla^2 \phi_i(U_i x) = \nabla^2 \phi_i(x_{[i]})
  \end{align*}

  Map back to place in original matrix:\\

  $\nabla^2 f_i(x) \approx U_i^T B_{[i]} U_i$\\

  Complete Hessian approximation then becomes:\\

  $B = \sum_i U_i^T B_{[i]} U_i$\\

  which can be used in trust region algo to get $p_k$:\\
  
  $B_k p_k = -\nabla f_k$.
  
  \end{multicols*}
\end {document}


